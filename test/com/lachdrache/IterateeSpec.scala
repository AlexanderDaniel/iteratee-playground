package com.lachdrache

import java.io.ByteArrayInputStream
import java.util.concurrent.atomic.AtomicInteger

import org.scalatest.FunSpec
import org.scalatestplus.play.OneAppPerSuite
import play.api.libs.concurrent.Promise
import play.api.libs.iteratee._
import play.api.test.Helpers._
import scala.concurrent.ExecutionContext.Implicits.global

import scala.concurrent.{ExecutionContext, Future}

class IterateeSpec extends FunSpec with OneAppPerSuite {

  // http://www.playframework.com/documentation/2.3.x/Iteratees
  describe("primitive iteratees: done") {

    def folder(step: Step[String, Int]): Future[Option[Int]] = step match {
      case Step.Done(a, e) => Future(Some(a))
      case Step.Cont(k) => Future(None)
      case Step.Error(msg, e) => Future(None)
    }

    val doneIteratee = new Iteratee[String, Int] {
      def fold[B](folder: Step[String, Int] => Future[B])(implicit ec: ExecutionContext): Future[B] =
        folder(Step.Done(1, Input.Empty))
    }

    it("fold doneIteratee") {
      assertResult(Some(1)) {
        val eventuallyMaybeResult: Future[Option[Int]] = doneIteratee.fold(folder)
        await(eventuallyMaybeResult)
      }
    }
  }

  // http://mandubian.com/2012/08/27/understanding-play2-iteratees-for-normal-humans/
  describe("summing iteratee") {
    it("using Iteratee.fold to calculate the sum via fold") {
      val enumerator: Enumerator[Int] = Enumerator(1, 2, 3, 4, 5)
      assertResult(15) {
        val future: Future[Int] = enumerator.run(
          Iteratee.fold(0) { (total, el) => total + el}
        )
        await(future)
      }
    }
  }

  describe("file enumerator") {
    it("fold on iteratee is called 3 times for chunk size 5 on a input stream with 13 bytes") {
      val counter = new AtomicInteger(0)
      val inputStr = List.fill(13)('a').mkString
      val bytes = inputStr.getBytes("UTF-8")
      assert(bytes.length === 13)
      val is = new ByteArrayInputStream(bytes)

      val enumerator: Enumerator[Array[Byte]] = Enumerator.fromStream(is, chunkSize = 5)
      assertResult(inputStr) {
        val future: Future[String] = enumerator.run(
          Iteratee.fold("") { (z, el) => counter.getAndIncrement; z + new String(el, "UTF-8") }
        )
        await(future)
      }
      assert(counter.get() === 3)
    }
  }

  describe("enumerator generated by a callback") {
    it("should return the first element with Iteratee.head") {
      val enumerator: Enumerator[String] = Enumerator.generateM(
        Promise.timeout(
          Some("current time %s".format(new java.util.Date())),
          1
        )
      )
      val future: Future[Option[String]] = enumerator.run(Iteratee.head)
      val optStr = await(future)
      assert(optStr.get.startsWith("current time"))
    }
  }

  describe("reusing an iteratee") {
    val iteratee: Iteratee[Int, Int] = Iteratee.fold[Int, Int](0)((total, el) => total + el)

    it("for 3 ints") {
      val enumerator = Enumerator(1,2,3)
      enumerator(iteratee)
      assertResult(6) {
        val future: Future[Int] = enumerator.run(iteratee)
        await(future)
      }
    }

    it("for 5 ints") {
      val enumerator: Enumerator[Int] = Enumerator(1,2,3,4,5)
      enumerator(iteratee)
      assertResult(15) {
        await(enumerator.run(iteratee))
      }
    }
  }

  describe("getChunks on Iteratee companion object") {
    it("should return all chunks") {
      val enumerator = Enumerator(1,2,13)
      assertResult(List(1,2,13)) {
        val future: Future[List[Int]] = enumerator run Iteratee.getChunks
        await(future)
      }
    }
  }

  describe("Iteratee computing the total of the 2 first elements") {
    def total2Chunks: Iteratee[Int, Int] = {
      def step(idx: Int, total: Int)(i: Input[Int]): Iteratee[Int, Int] = i match {
        case Input.EOF | Input.Empty => Done(total, Input.EOF)
        case Input.El(e) => if (idx < 2) Cont[Int, Int](i => step(idx+1, total + e)(i))
                            else Done(total, Input.EOF)
      }
      Cont[Int, Int](i => step(0, 0)(i))
    }

    it("should return 30") {
      assertResult(30) {
        val future: Future[Int] = Enumerator(10, 20, 5) run total2Chunks
        await(future)
      }
    }

    it("will even work for an never-ending enumerator") {
      awaitAndAssert(2) {
        Enumerator.repeat(1) run total2Chunks
      }
    }
  }

  describe("types matter") {
    val iterator = Iteratee.fold[Int, Int](0)((total, el) => total + el)
    val enumerator = Enumerator(1, 234, 455, 987)

    it("difference between Enumerator.apply and Enumerator.run") {
      val totalIteratee: Future[Iteratee[Int, Int]] = enumerator apply iterator
      val total: Future[Int] = enumerator run iterator
    }

    it("Iteratee is a Future[Iteratee") {
      val future: Future[Iteratee[Int, Int]] = enumerator apply iterator
      val it: Iteratee[Int, Int] = Iteratee.flatten(future)

      // converts an Iteratee to a Future[Iteratee]
      val future1: Future[Iteratee[Int, Int]] = Future.successful(it)
      val future2: Future[Iteratee[Int, Int]] = it.unflatten.map(_.it)
    }
  }

  describe("enumeratee") {
    val enumerator = Enumerator(1, 2, 3)
    val iteratee: Iteratee[String, List[String]] = Iteratee.getChunks[String]

    it("should convert ints to strings") {
      awaitAndAssert(List("1", "2", "3")) {
        val future: Future[List[String]] = enumerator through Enumeratee.map(_.toString) run iteratee
        future
      }
    }

    it("in two steps") {
      val e: Enumerator[String] = enumerator through Enumeratee.map(_.toString)
      awaitAndAssert(List("1", "2", "3")) {
        e run iteratee
      }
    }
  }

  describe("enumeratee can transform an iteratee") {
    val stringIteratee: Iteratee[String, List[String]] = Iteratee.getChunks[String]
    val intIteratee: Iteratee[Int, List[String]] = Enumeratee.map[Int](_.toString) transform stringIteratee

    it("running intIteratee") {
      awaitAndAssert(List("1", "2", "3")) {
        Enumerator(1, 2, 3) run intIteratee
      }
    }
  }

  describe("enumeratee can be composed with an enumeratee") {
    val enumeratee1: Enumeratee[String, Int] = Enumeratee.map[String](_.toInt)
    val enumeratee2: Enumeratee[Int, Option[Int]] = Enumeratee.map[Int](Some(_))
    val enumerateeComposed: Enumeratee[String, Option[Int]] = enumeratee1 compose enumeratee2

    it("running composed enumeratee") {
      awaitAndAssert(List[Option[Int]](Some(13), Some(17))) {
        Enumerator("13", "17") through enumerateeComposed run Iteratee.getChunks[Option[Int]]
      }
    }
  }

  def awaitAndAssert[A](expected: A)(thunk: => Future[A]) {
    assertResult(expected) {
      await {
        thunk
      }
    }
  }

}