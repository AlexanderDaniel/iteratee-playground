package com.lachdrache

import java.io.ByteArrayInputStream
import java.util.concurrent.atomic.AtomicInteger

import org.scalatest.FunSpec
import org.scalatestplus.play.OneAppPerSuite
import play.api.libs.concurrent.Promise
import play.api.libs.iteratee._
import play.api.test.Helpers._
import scala.concurrent.ExecutionContext.Implicits.global

import scala.concurrent.{ExecutionContext, Future}

class IterateeSpec extends FunSpec with OneAppPerSuite {

  // http://www.playframework.com/documentation/2.3.x/Iteratees
  describe("primitive iteratees: done") {

    def folder(step: Step[String, Int]): Future[Option[Int]] = step match {
      case Step.Done(a, e) => Future(Some(a))
      case Step.Cont(k) => Future(None)
      case Step.Error(msg, e) => Future(None)
    }

    val doneIteratee = new Iteratee[String, Int] {
      def fold[B](folder: Step[String, Int] => Future[B])(implicit ec: ExecutionContext): Future[B] =
        folder(Step.Done(1, Input.Empty))
    }

    it("fold doneIteratee") {
      assertResult(Some(1)) {
        val eventuallyMaybeResult: Future[Option[Int]] = doneIteratee.fold(folder)
        await(eventuallyMaybeResult)
      }
    }
  }

  // http://mandubian.com/2012/08/27/understanding-play2-iteratees-for-normal-humans/
  describe("summing iteratee") {
    it("using Iteratee.fold to calculate the sum via fold") {
      val enumerator: Enumerator[Int] = Enumerator(1, 2, 3, 4, 5)
      assertResult(15) {
        val future: Future[Int] = enumerator.run(
          Iteratee.fold(0) { (total, el) => total + el}
        )
        await(future)
      }
    }
  }

  describe("file enumerator") {
    it("fold on iteratee is called 3 times for chunk size 5 on a input stream with 13 bytes") {
      val counter = new AtomicInteger(0)
      val inputStr = List.fill(13)('a').mkString
      val bytes = inputStr.getBytes("UTF-8")
      assert(bytes.length === 13)
      val is = new ByteArrayInputStream(bytes)

      val enumerator: Enumerator[Array[Byte]] = Enumerator.fromStream(is, chunkSize = 5)
      assertResult(inputStr) {
        val future: Future[String] = enumerator.run(
          Iteratee.fold("") { (z, el) => counter.getAndIncrement; z + new String(el, "UTF-8") }
        )
        await(future)
      }
      assert(counter.get() === 3)
    }
  }

  describe("enumerator generated by a callback") {
    it("should return the first element with Iteratee.head") {
      val enumerator: Enumerator[String] = Enumerator.generateM(
        Promise.timeout(
          Some("current time %s".format(new java.util.Date())),
          1
        )
      )
      val future: Future[Option[String]] = enumerator.run(Iteratee.head)
      val optStr = await(future)
      assert(optStr.get.startsWith("current time"))
    }
  }

  describe("reusing an iteratee") {
    val iteratee: Iteratee[Int, Int] = Iteratee.fold[Int, Int](0)((total, el) => total + el)

    it("for 3 ints") {
      val enumerator = Enumerator(1,2,3)
      enumerator(iteratee)
      assertResult(6) {
        val future: Future[Int] = enumerator.run(iteratee)
        await(future)
      }
    }

    it("for 5 ints") {
      val enumerator: Enumerator[Int] = Enumerator(1,2,3,4,5)
      enumerator(iteratee)
      assertResult(15) {
        await(enumerator.run(iteratee))
      }
    }
  }

  describe("getChunks on Iteratee companion object") {
    it("should return all chunks") {
      val enumerator = Enumerator(1,2,13)
      assertResult(List(1,2,13)) {
        val future: Future[List[Int]] = enumerator run Iteratee.getChunks
        await(future)
      }
    }
  }

  describe("Iteratee computing the total of the 2 first elements") {
    def total2Chunks: Iteratee[Int, Int] = {
      def step(idx: Int, total: Int)(i: Input[Int]): Iteratee[Int, Int] = i match {
        case Input.EOF | Input.Empty => Done(total, Input.EOF)
        case Input.El(e) => if (idx < 2) Cont[Int, Int](i => step(idx+1, total + e)(i))
                            else Done(total, Input.EOF)
      }
      Cont[Int, Int](i => step(0, 0)(i))
    }

    it("should return 30") {
      assertResult(30) {
        val future: Future[Int] = Enumerator(10, 20, 5) run total2Chunks
        await(future)
      }
    }

    it("will even work for an never-ending enumerator") {
      awaitAndAssert(2) {
        Enumerator.repeat(1) run total2Chunks
      }
    }
  }

  describe("types matter") {
    val iterator = Iteratee.fold[Int, Int](0)((total, el) => total + el)
    val enumerator = Enumerator(1, 234, 455, 987)

    it("difference between Enumerator.apply and Enumerator.run") {
      val totalIteratee: Future[Iteratee[Int, Int]] = enumerator apply iterator
      val total: Future[Int] = enumerator run iterator
    }

    it("Iteratee is a Future[Iteratee") {
      val future: Future[Iteratee[Int, Int]] = enumerator apply iterator
      val it: Iteratee[Int, Int] = Iteratee.flatten(future)

      // converts an Iteratee to a Future[Iteratee]
      val future1: Future[Iteratee[Int, Int]] = Future.successful(it)
      val future2: Future[Iteratee[Int, Int]] = it.unflatten.map(_.it)
    }
  }

  describe("enumeratee") {
    val enumerator = Enumerator(1, 2, 3)
    val iteratee: Iteratee[String, List[String]] = Iteratee.getChunks[String]

    it("should convert ints to strings") {
      awaitAndAssert(List("1", "2", "3")) {
        val future: Future[List[String]] = enumerator through Enumeratee.map(_.toString) run iteratee
        future
      }
    }

    it("in two steps") {
      val e: Enumerator[String] = enumerator through Enumeratee.map(_.toString)
      awaitAndAssert(List("1", "2", "3")) {
        e run iteratee
      }
    }
  }

  describe("enumeratee can transform an iteratee") {
    val stringIteratee: Iteratee[String, List[String]] = Iteratee.getChunks[String]
    val intIteratee: Iteratee[Int, List[String]] = Enumeratee.map[Int](_.toString) transform stringIteratee

    it("running intIteratee") {
      awaitAndAssert(List("1", "2", "3")) {
        Enumerator(1, 2, 3) run intIteratee
      }
    }
  }

  describe("enumeratee can be composed with an enumeratee") {
    val enumeratee1: Enumeratee[String, Int] = Enumeratee.map[String](_.toInt)
    val enumeratee2: Enumeratee[Int, Option[Int]] = Enumeratee.map[Int](Some(_))
    val enumerateeComposed: Enumeratee[String, Option[Int]] = enumeratee1 compose enumeratee2

    it("running composed enumeratee") {
      awaitAndAssert(List[Option[Int]](Some(13), Some(17))) {
        Enumerator("13", "17") through enumerateeComposed run Iteratee.getChunks[Option[Int]]
      }
    }
  }

  // http://jazzy.id.au/default/2012/11/06/iteratees_for_imperative_programmers.html
  def dropWhile(p: Char => Boolean): Iteratee[Char, Unit] = Cont {
    case in@Input.El(char) if !p(char) => Done(Unit, in)
    case in@Input.EOF => Done(Unit, in)
    case _ => dropWhile(p)
  }

  def dropSpaces = dropWhile(c => c.isWhitespace)

  def takeWhile(p: Char => Boolean, data: Seq[Char] = IndexedSeq[Char]()): Iteratee[Char, Seq[Char]] = Cont {
    case in@Input.El(char) => if (p(char)) {
      takeWhile(p, data :+ char)
    } else {
      Done(data, in)
    }
    case in@Input.EOF => Done(data, in)
    case _ => takeWhile(p, data)
  }

  describe("takeWhile") {
    it("some characters are remaining") {
      val enumerator: Enumerator[Char] = Enumerator("abc,".toList:_*)
      awaitAndAssert(Seq('a', 'b', 'c')) {
        enumerator run takeWhile(_!=',')
      }
    }

    it("stops at EOF") {
      val enumerator: Enumerator[Char] = Enumerator('a', 'b')
      awaitAndAssert(Seq('a', 'b')) {
        enumerator run takeWhile(_ != ',')
      }
    }
  }

  def peek: Iteratee[Char, Option[Char]] = Cont {
    case in@Input.El(char) => Done(Some(char), in)
    case in@Input.EOF => Done(None, in)
    case _ => peek
  }

  def takeOne: Iteratee[Char, Option[Char]] = Cont {
    case in@Input.El(char) => Done(Some(char))
    case in@Input.EOF => Done(None, in)
    case _ => takeOne
  }

  def expect(char: Char): Iteratee[Char, Unit] =
    takeOne.flatMap {
      case Some(c) if c==char => Done(Unit)
      case Some(c) => Error(s"Expected $char but got $c", Input.El(c))
      case None => Error(s"Premature end of input, expected: $char", Input.EOF)
    }

  def unquoted = takeWhile(c => c != ',' && c != '\n') map (_.mkString.trim)

  def quotedWithoutSupportForEscapedQuotes = for {
    _ <- expect('"')
    value <- takeWhile(_ != '"')
    _ <- expect('"')
  } yield value.mkString

  def quoted(value: Seq[Char] = IndexedSeq[Char]()): Iteratee[Char, String] = for {
    _ <- expect('"')
    chars <- takeWhile(_ != '"')
    _ <- expect('"')
    nextChar <- peek
    value <- nextChar match {
      case Some('"') => quoted(value ++ chars :+ '"')
      case _ => Done[Char, String]((value ++ chars).mkString)
    }
  } yield value

  def value = for {
    char <- peek
    v <- char match {
      case Some('"') => quoted()
      case None => Error[Char]("premature end of input, expected a value", Input.EOF)
      case _ => unquoted
    }
  } yield v

  def values(state: Seq[String] = IndexedSeq[String]()): Iteratee[Char, Seq[String]] = for {
    _ <- dropSpaces
    v <- value
    _ <- dropSpaces
    nextChar <- takeOne
    vs <- nextChar match {
      case Some('\n') | None => Done[Char, Seq[String]](state :+ v)
      case Some(',') => values(state :+ v)
      case Some(other) => Error(s"Expected comma, newline or EOF, but found $other", Input.El(other))
    }
  } yield vs

  def csv: Enumeratee[Char, Seq[String]] = Enumeratee.grouped(values())

  // From the Scaladoc of [[Enumeratee.grouped]]
  def takeLine: Iteratee[Char, String] = for {
    line <- Enumeratee.takeWhile[Char](_ != '\n') transform Iteratee.getChunks
    _ <- Enumeratee.take(1) &>> Iteratee.ignore[Char]
  } yield line.mkString

  def asLinesEnumeratee: Enumeratee[Char, String] = Enumeratee.grouped(takeLine)

  def asLinesIteratee: Iteratee[Char, List[String]] = asLinesEnumeratee transform Iteratee.getChunks

  def awaitAndAssert[A](expected: A)(thunk: => Future[A]) {
    assertResult(expected) {
      await {
        thunk
      }
    }
  }

}