package com.lachdrache

import java.io.ByteArrayInputStream
import java.util.concurrent.atomic.AtomicInteger

import org.scalatest.FunSpec
import org.scalatestplus.play.OneAppPerSuite
import play.api.libs.concurrent.Promise
import play.api.libs.iteratee.{Enumerator, Input, Iteratee, Step}
import play.api.test.Helpers._
import scala.concurrent.ExecutionContext.Implicits.global

import scala.concurrent.{ExecutionContext, Future}

class IterateeSpec extends FunSpec with OneAppPerSuite {

  // http://www.playframework.com/documentation/2.3.x/Iteratees
  describe("primitive iteratees: done") {

    def folder(step: Step[String, Int]): Future[Option[Int]] = step match {
      case Step.Done(a, e) => Future(Some(a))
      case Step.Cont(k) => Future(None)
      case Step.Error(msg, e) => Future(None)
    }

    val doneIteratee = new Iteratee[String, Int] {
      def fold[B](folder: Step[String, Int] => Future[B])(implicit ec: ExecutionContext): Future[B] =
        folder(Step.Done(1, Input.Empty))
    }

    it("fold doneIteratee") {
      assertResult(Some(1)) {
        val eventuallyMaybeResult: Future[Option[Int]] = doneIteratee.fold(folder)
        await(eventuallyMaybeResult)
      }
    }
  }

  // http://mandubian.com/2012/08/27/understanding-play2-iteratees-for-normal-humans/
  describe("summing iteratee") {
    it("using Iteratee.fold to calculate the sum via fold") {
      val enumerator: Enumerator[Int] = Enumerator(1, 2, 3, 4, 5)
      assertResult(15) {
        val future: Future[Int] = enumerator.run(
          Iteratee.fold(0) { (total, el) => total + el}
        )
        await(future)
      }
    }
  }

  describe("file enumerator") {
    it("fold on iteratee is called 3 times for chunk size 5 on a input stream with 13 bytes") {
      val counter = new AtomicInteger(0)
      val inputStr = List.fill(13)('a').mkString
      val bytes = inputStr.getBytes("UTF-8")
      assert(bytes.length === 13)
      val is = new ByteArrayInputStream(bytes)

      val enumerator: Enumerator[Array[Byte]] = Enumerator.fromStream(is, chunkSize = 5)
      assertResult(inputStr) {
        val future: Future[String] = enumerator.run(
          Iteratee.fold("") { (z, el) => counter.getAndIncrement; z + new String(el, "UTF-8") }
        )
        await(future)
      }
      assert(counter.get() === 3)
    }
  }

  describe("enumerator generated by a callback") {
    it("should return the first element with Iteratee.head") {
      val enumerator: Enumerator[String] = Enumerator.generateM(
        Promise.timeout(
          Some("current time %s".format(new java.util.Date())),
          1
        )
      )
      val future: Future[Option[String]] = enumerator.run(Iteratee.head)
      val optStr = await(future)
      assert(optStr.get.startsWith("current time"))
    }
  }

  describe("reusing an iteratee") {
    val iteratee: Iteratee[Int, Int] = Iteratee.fold[Int, Int](0)((total, el) => total + el)

    it("for 3 ints") {
      val enumerator = Enumerator(1,2,3)
      enumerator(iteratee)
      assertResult(6) {
        val future: Future[Int] = enumerator.run(iteratee)
        await(future)
      }
    }

    it("for 5 ints") {
      val enumerator: Enumerator[Int] = Enumerator(1,2,3,4,5)
      enumerator(iteratee)
      assertResult(15) {
        await(enumerator.run(iteratee))
      }
    }
  }



}